// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteRun = `-- name: DeleteRun :exec
DELETE FROM runs WHERE id = $1
`

func (q *Queries) DeleteRun(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRun, id)
	return err
}

const getAllRunsWithUsers = `-- name: GetAllRunsWithUsers :many
SELECT 
    r.id, 
    r.data, 
    r.image, 
    r.created_at,
    u.id as user_id,
    u.name as user_name,
    u.display_username as user_username
FROM runs r
LEFT JOIN "user" u ON r.user_id = u.id
ORDER BY r.created_at DESC
`

type GetAllRunsWithUsersRow struct {
	ID           pgtype.UUID      `json:"id"`
	Data         []byte           `json:"data"`
	Image        string           `json:"image"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UserID       pgtype.Text      `json:"userId"`
	UserName     pgtype.Text      `json:"userName"`
	UserUsername pgtype.Text      `json:"userUsername"`
}

func (q *Queries) GetAllRunsWithUsers(ctx context.Context) ([]GetAllRunsWithUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllRunsWithUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRunsWithUsersRow
	for rows.Next() {
		var i GetAllRunsWithUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Data,
			&i.Image,
			&i.CreatedAt,
			&i.UserID,
			&i.UserName,
			&i.UserUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentRunsForUser = `-- name: GetRecentRunsForUser :many
SELECT id, user_id, data, created_at, image 
FROM runs 
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetRecentRunsForUserParams struct {
	UserID pgtype.Text `json:"userId"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetRecentRunsForUser(ctx context.Context, arg GetRecentRunsForUserParams) ([]Run, error) {
	rows, err := q.db.Query(ctx, getRecentRunsForUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Data,
			&i.CreatedAt,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRuns = `-- name: GetRuns :many
SELECT id, user_id, data, created_at, image FROM runs
ORDER BY created_at DESC
`

func (q *Queries) GetRuns(ctx context.Context) ([]Run, error) {
	rows, err := q.db.Query(ctx, getRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Data,
			&i.CreatedAt,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRunsByUserId = `-- name: GetRunsByUserId :many
SELECT id, user_id, data, created_at, image 
FROM runs 
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetRunsByUserId(ctx context.Context, userID pgtype.Text) ([]Run, error) {
	rows, err := q.db.Query(ctx, getRunsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Data,
			&i.CreatedAt,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT id, name, username 
FROM "user" 
WHERE id = $1
`

type GetUserByIdRow struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Username string `json:"username"`
}

func (q *Queries) GetUserById(ctx context.Context, id string) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(&i.ID, &i.Name, &i.Username)
	return i, err
}

const saveRun = `-- name: SaveRun :one
INSERT INTO runs (user_id, data, image, created_at)
VALUES ($1, $2, $3, NOW())
RETURNING id, user_id, data, created_at, image
`

type SaveRunParams struct {
	UserID pgtype.Text `json:"userId"`
	Data   []byte      `json:"data"`
	Image  string      `json:"image"`
}

func (q *Queries) SaveRun(ctx context.Context, arg SaveRunParams) (Run, error) {
	row := q.db.QueryRow(ctx, saveRun, arg.UserID, arg.Data, arg.Image)
	var i Run
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Data,
		&i.CreatedAt,
		&i.Image,
	)
	return i, err
}

const searchUsersByName = `-- name: SearchUsersByName :many
SELECT id, name, username, display_username
FROM "user"
WHERE name ILIKE '%' || $1 || '%' OR username ILIKE '%' || $1 || '%'
ORDER BY name
LIMIT $2
`

type SearchUsersByNameParams struct {
	Column1 pgtype.Text `json:"column1"`
	Limit   int32       `json:"limit"`
}

type SearchUsersByNameRow struct {
	ID              string `json:"id"`
	Name            string `json:"name"`
	Username        string `json:"username"`
	DisplayUsername string `json:"displayUsername"`
}

func (q *Queries) SearchUsersByName(ctx context.Context, arg SearchUsersByNameParams) ([]SearchUsersByNameRow, error) {
	rows, err := q.db.Query(ctx, searchUsersByName, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUsersByNameRow
	for rows.Next() {
		var i SearchUsersByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.DisplayUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRunWithUser = `-- name: UpdateRunWithUser :one
UPDATE runs 
SET user_id = $2
WHERE id = $1
RETURNING id, user_id, data, created_at, image
`

type UpdateRunWithUserParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.Text `json:"userId"`
}

func (q *Queries) UpdateRunWithUser(ctx context.Context, arg UpdateRunWithUserParams) (Run, error) {
	row := q.db.QueryRow(ctx, updateRunWithUser, arg.ID, arg.UserID)
	var i Run
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Data,
		&i.CreatedAt,
		&i.Image,
	)
	return i, err
}
